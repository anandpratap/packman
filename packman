#!/usr/bin/env ruby

if not ENV.has_key? 'PACKMAN_ROOT'
  print "[Error]: #{File.expand_path(File.dirname(__FILE__))}/"+
    "setup.sh is not sourced!\n"
  exit
end

$LOAD_PATH << "#{ENV['PACKMAN_ROOT']}/framework"
$LOAD_PATH << "#{ENV['PACKMAN_ROOT']}/packages"
require 'packman_framework'

# Check if there is already a PACKMAN running.
pid_file = "#{ENV['PACKMAN_ROOT']}/.pid"
if File.exist? pid_file and PACKMAN::CommandLine.process_exclusive?
  pid = File.open(pid_file, 'r').read.strip
  PACKMAN::CLI.report_error "There is another "+
    "#{PACKMAN::CLI.green 'packman'} process ("+
    "#{PACKMAN::CLI.red pid}) running! Please "+
    "wait until it is completed."
else
  File.open(pid_file, 'w') do |file|
    file << Process.pid
  end
end

if not PACKMAN::Commands.respond_to? PACKMAN::CommandLine.subcommand
  PACKMAN::CLI.report_error "Unknown subcommand "+
    "#{PACKMAN::CommandLine.subcommand}!"
end

PACKMAN::Commands.send PACKMAN::CommandLine.subcommand

# Delete the pid file.
PACKMAN.rm pid_file if PACKMAN::CommandLine.process_exclusive?
